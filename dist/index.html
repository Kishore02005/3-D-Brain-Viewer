<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>HI-Labs Brain Viewer â€” Standalone</title>
  <style>
    html,body { height:100%; margin:0; background:#04101a; color:#e6f0ff; font-family:Arial,Helvetica,sans-serif; }
    #canvas { width:100%; height:100vh; display:block; }
    .overlay { position: absolute; top: 12px; left: 12px; background: rgba(0,0,0,0.35); padding:10px 12px; border-radius:8px; }
    .sidebar { position: absolute; right: 12px; top: 12px; width:320px; max-height:90vh; overflow:auto; background: rgba(2,6,16,0.6); padding:12px; border-radius:10px; }
    h1 { margin:0 0 6px 0; font-size:18px; }
    p { margin:0 0 8px 0; font-size:13px; color:#bcd3ff; }
    button { background:#5b21b6;color:white;border:none;padding:8px 10px;border-radius:6px;cursor:pointer }
    .region { margin-bottom:10px; padding:8px; background:rgba(255,255,255,0.03); border-radius:6px; }
  </style>
</head>
<body>
  <div class="overlay"><h1>HI-Labs Brain Viewer</h1><div>Click a region in the scene to focus. Drag to rotate.</div></div>
  <div id="canvas"></div>
  <div class="sidebar" id="sidebar"><h2>Regions</h2><div id="regions"></div></div>

  <!-- Three.js and GLTFLoader from CDN -->
  <script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>
  <script src="https://unpkg.com/three@0.158.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://unpkg.com/three@0.158.0/examples/js/loaders/GLTFLoader.js"></script>

  <script>
    const container = document.getElementById('canvas');
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x04101a);
    const camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(0, 0.8, 2.5);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio ? window.devicePixelRatio : 1);
    container.appendChild(renderer.domElement);

    const hemi = new THREE.HemisphereLight(0xffffff, 0x080820, 0.6);
    scene.add(hemi);
    const dir = new THREE.DirectionalLight(0xffffff, 0.6);
    dir.position.set(5,5,5); scene.add(dir);

    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enablePan = true;
    controls.enableZoom = true;

    const loader = new THREE.GLTFLoader();
    const MODEL = 'models/brain_HILabs.glb';

    const regionMap = {
      "Stillness_Prefrontal": { lab: "Lab of Stillness", display: "Prefrontal Cortex", fact: "Responsible for planning, attention, and self-control.", color: 0xBEE6FF },
      "Stillness_Cingulate": { lab: "Lab of Stillness", display: "Anterior Cingulate", fact: "Involved in attention and emotional regulation.", color: 0x9FC9FF },
      "Echoes_Temporal": { lab: "Lab of Echoes", display: "Temporal Lobe", fact: "Processes sounds and language-related signals.", color: 0xFFE7AF },
      "Echoes_AuditoryCortex": { lab: "Lab of Echoes", display: "Auditory Cortex", fact: "Primary area for hearing and auditory pattern recognition.", color: 0xFFD27A },
      "Motor_Primary": { lab: "Lab of Movement", display: "Primary Motor Cortex", fact: "Executes voluntary movements.", color: 0xCFFFE6 },
      "Cerebellum": { lab: "Lab of Movement", display: "Cerebellum", fact: "Coordinates balance and fine motor control.", color: 0xD9EEFF },
      "Brainstem": { lab: "Core", display: "Brainstem", fact: "Controls vital functions like breathing and heart rate.", color: 0xDADADA }
    };

    let regionObjects = {};
    loader.load(MODEL, gltf => {
      const root = gltf.scene;
      scene.add(root);

      // Collect named meshes
      root.traverse(child => {
        if (child.isMesh && child.name) {
          if (regionMap[child.name]) {
            regionObjects[child.name] = child;
            // make material emissive for aura effect
            child.material = child.material.clone();
            child.material.transparent = true;
            child.material.opacity = 0.85;
            child.material.emissive = new THREE.Color(regionMap[child.name].color);
            child.material.emissiveIntensity = 0.6;
            child.userData.regionName = child.name;
          }
        }
      });

      populateSidebar();
    }, undefined, err => {
      const msg = document.createElement('div'); msg.innerText = 'Failed to load GLB. Make sure brain_HILabs.glb is in the models/ folder.';
      document.body.appendChild(msg);
      console.error(err);
    });

    function populateSidebar(){
      const container = document.getElementById('regions');
      Object.keys(regionMap).forEach(key => {
        const r = regionMap[key];
        const el = document.createElement('div');
        el.className = 'region';
        el.innerHTML = '<strong>' + r.display + '</strong><div style="font-size:12px;color:#bcd3ff">' + r.lab + '</div><div style="margin-top:6px;font-size:13px">' + r.fact + '</div>';
        el.onclick = () => focusRegion(key);
        container.appendChild(el);
      });
    }

    let focused = null;
    function focusRegion(name){
      if (!regionObjects[name]) return;
      focused = regionObjects[name];
      const target = new THREE.Vector3(); focused.getWorldPosition(target);
      // animate camera via simple lerp
      const start = camera.position.clone();
      const end = new THREE.Vector3(target.x + 0.6, target.y + 0.2, target.z + 1.0);
      let t = 0;
      const steps = 40;
      const id = setInterval(()=>{
        t++;
        camera.position.lerpVectors(start, end, t/steps);
        camera.lookAt(target);
        if (t>=steps) clearInterval(id);
      }, 12);
      // flash emissive
      const mat = focused.material;
      const orig = mat.emissiveIntensity;
      mat.emissiveIntensity = 1.6;
      setTimeout(()=>{ mat.emissiveIntensity = orig; }, 800);
    }

    // Raycast for clicking in canvas
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    renderer.domElement.addEventListener('pointerdown', (ev) => {
      const rect = renderer.domElement.getBoundingClientRect();
      mouse.x = ((ev.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = - ((ev.clientY - rect.top) / rect.height) * 2 + 1;
      raycaster.setFromCamera(mouse, camera);
      const hits = raycaster.intersectObjects(Object.values(regionObjects), true);
      if (hits.length) {
        const name = hits[0].object.userData.regionName;
        if (name) focusRegion(name);
      }
    });

    function animate(){ requestAnimationFrame(animate); controls.update(); renderer.render(scene, camera); }
    animate();

    window.addEventListener('resize', ()=>{ camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
  </script>
</body>
</html>
